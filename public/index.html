<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Privater Invite-Chat</title>
<style>
  :root{--bg:#0f1113;--panel:#121316;--accent:#ff79c6;--muted:#bfc3c8;--userA:#8be9fd;--userB:#50fa7b}
  body{margin:0;font-family:Inter,Arial,Helvetica,sans-serif;background:var(--bg);color:#e9e9ea;display:flex;align-items:center;justify-content:center;height:100vh}
  .card{width:95%;max-width:920px;background:var(--panel);border-radius:12px;padding:18px;box-shadow:0 12px 48px rgba(0,0,0,0.6)}
  h1{margin:0;color:var(--accent);font-size:20px}
  .muted{color:var(--muted);font-size:13px}
  .flex{display:flex;gap:12px;align-items:center;margin-top:12px}
  input[type="text"], input[type="password"], textarea{padding:10px;border-radius:8px;border:1px solid #222;background:#0e0f10;color:#fff;outline:none;flex:1}
  button{padding:10px 12px;border-radius:8px;border:none;background:var(--accent);color:#111;font-weight:600;cursor:pointer}
  #chatArea{display:none;margin-top:12px;height:60vh;display:flex;gap:12px}
  #messages{flex:1;background:linear-gradient(180deg,#0d0e10,#0b0b0c);border-radius:10px;padding:12px;overflow:auto;display:flex;flex-direction:column;gap:10px}
  .msg{max-width:78%;padding:10px 12px;border-radius:10px;line-height:1.35;background:rgba(255,255,255,0.02)}
  .meta{font-size:12px;color:var(--muted);margin-bottom:6px}
  .mine{align-self:flex-end;border:1px solid rgba(139,233,253,0.12);color:var(--userA)}
  .their{align-self:flex-start;border:1px solid rgba(80,250,123,0.08);color:var(--userB)}
  #right{width:260px}
  .usersBox{background:#0b0b0c;padding:10px;border-radius:10px;min-height:80px;color:var(--muted)}
  .composer{display:flex;gap:8px;align-items:center;margin-top:10px}
  .notice{margin-top:10px;color:var(--muted);font-size:13px}
  .hidden{display:none}
</style>
</head>
<body>
<div class="card">
  <h1>Privater Invite-Chat</h1>
  <div class="muted">Nur mit Einladungscode (max. 5 Teilnehmer). Nachrichten bleiben 24 Stunden sichtbar.</div>

  <div id="setup" class="muted" style="margin-top:12px">
    <div style="margin-top:8px">Profil anlegen (wird lokal gespeichert):</div>
    <div class="flex" style="margin-top:8px">
      <input id="name" type="text" placeholder="Dein Anzeigename" />
      <button id="saveProfile">Profil speichern</button>
    </div>

    <div style="margin-top:12px">Einladungscode eingeben:</div>
    <div class="flex" style="margin-top:8px">
      <input id="code" type="text" placeholder="z. B. 15001" />
      <button id="enterCode">Eintritt</button>
    </div>
    <div class="notice" id="setupNotice"></div>
  </div>

  <div id="chatArea">
    <div id="left">
      <div id="messages" aria-live="polite"></div>
      <div class="composer">
        <textarea id="text" placeholder="Schreibe eine Nachricht..."></textarea>
        <button id="sendBtn">Senden</button>
      </div>
      <div class="notice" id="notice">Nicht verbunden.</div>
    </div>

    <div id="right">
      <div class="usersBox">
        <div style="font-weight:600">Raum</div>
        <div id="roomMeta" style="margin-top:8px" class="muted">—</div>
        <div style="margin-top:10px;font-weight:600">Mitglieder</div>
        <div id="usersList" style="margin-top:8px" class="muted">—</div>
      </div>

      <div style="margin-top:12px" class="muted">
        Teilen nur mit vertrauenswürdigen Personen.<br>
        <div style="margin-top:8px">Code: <strong id="displayCode">—</strong></div>
      </div>
    </div>
  </div>
</div>

<script src="/socket.io/socket.io.js"></script>
<script>
/*
Behavior:
- If served by the server (same origin), no BACKEND_URL needed.
- If you host frontend separately, set BACKEND_URL to your server (e.g. https://your-app.onrender.com)
*/
const BACKEND_URL = ''; // set if front and backend are on different origins

const nameInput = document.getElementById('name');
const saveProfileBtn = document.getElementById('saveProfile');
const setupNotice = document.getElementById('setupNotice');
const codeInput = document.getElementById('code');
const enterCodeBtn = document.getElementById('enterCode');
const setupDiv = document.getElementById('setup');
const chatArea = document.getElementById('chatArea');
const messagesDiv = document.getElementById('messages');
const textInput = document.getElementById('text');
const sendBtn = document.getElementById('sendBtn');
const notice = document.getElementById('notice');
const roomMeta = document.getElementById('roomMeta');
const usersList = document.getElementById('usersList');
const displayCode = document.getElementById('displayCode');

let socket = null;
let currentCode = null;
let localName = localStorage.getItem('pc_name') || '';

if(localName) nameInput.value = localName;

saveProfileBtn.addEventListener('click', () => {
  const v = nameInput.value.trim();
  if(!v) return setupNotice.textContent = 'Bitte Namen eingeben.';
  localStorage.setItem('pc_name', v);
  localName = v;
  setupNotice.textContent = 'Profil gespeichert.';
});

enterCodeBtn.addEventListener('click', async () => {
  const code = codeInput.value.trim();
  if(!code) return setupNotice.textContent = 'Bitte Code eingeben.';
  if(!localName) return setupNotice.textContent = 'Bitte zuerst Profil speichern.';
  try {
    const res = await fetch((BACKEND_URL || '') + '/api/join', {
      method: 'POST',
      headers: {'Content-Type':'application/json'},
      body: JSON.stringify({ code })
    });
    const j = await res.json();
    if(!res.ok) {
      setupNotice.textContent = 'Fehler: ' + (j.error || res.statusText);
      return;
    }
    connectSocket(code, localName);
  } catch (e) {
    console.error(e);
    setupNotice.textContent = 'Fehler beim Verbinden mit Server.';
  }
});

function appendMessage(msg){
  const wrapper = document.createElement('div');
  const meta = document.createElement('div');
  meta.className = 'meta';
  const time = new Date(msg.ts || Date.now());
  meta.textContent = `${msg.name} • ${time.toLocaleString()}`;
  const bubble = document.createElement('div');
  bubble.className = 'msg';
  bubble.textContent = msg.text;
  if(localName && msg.name === localName) bubble.classList.add('mine');
  else bubble.classList.add('their');
  wrapper.appendChild(meta);
  wrapper.appendChild(bubble);
  messagesDiv.appendChild(wrapper);
  messagesDiv.scrollTop = messagesDiv.scrollHeight;
}

function setConnected(code, expiresAt){
  currentCode = code;
  displayCode.textContent = code;
  setupDiv.style.display = 'none';
  chatArea.style.display = 'flex';
  notice.textContent = `Verbunden mit Code ${code}`;
  textInput.disabled = false;
  sendBtn.disabled = false;
  const expDate = new Date(expiresAt);
  const diff = Math.max(0, expDate - Date.now());
  const hours = Math.floor(diff / (1000*60*60));
  const mins = Math.floor((diff % (1000*60*60)) / (1000*60));
  roomMeta.textContent = `Läuft ab in ${hours} Std. ${mins} Min.`;
}

function setDisconnected(){
  currentCode = null;
  setupDiv.style.display = '';
  chatArea.style.display = 'none';
  notice.textContent = 'Nicht verbunden.';
  textInput.disabled = true;
  sendBtn.disabled = true;
  roomMeta.textContent = '—';
  usersList.textContent = '—';
}

async function connectSocket(code, name){
  socket = io(BACKEND_URL || undefined, { transports: ['websocket'] });

  socket.on('connect', () => {
    socket.emit('join', { code, name });
  });

  socket.on('join-error', (err) => {
    alert('Join Fehler: ' + (err.error || JSON.stringify(err)));
    socket.disconnect();
    setDisconnected();
  });

  socket.on('history', (msgs) => {
    messagesDiv.innerHTML = '';
    msgs.forEach(appendMessage);
    setConnected(code, Date.now() + (24*60*60*1000));
  });

  socket.on('message', (msg) => {
    appendMessage(msg);
    notifyNewMessage(msg);
  });

  socket.on('peer-joined', (info) => {
    usersList.textContent = info.name;
  });

  socket.on('room-meta', (meta) => {
    const expires = meta.expiresAt || (Date.now() + (24*60*60*1000));
    setConnected(code, expires);
    usersList.textContent = `Teilnehmer: ${meta.participantCount || 1}`;
  });

  socket.on('room-closed', () => {
    alert('Dieser Raum wurde geschlossen (abgelaufen).');
    socket.disconnect();
    setDisconnected();
  });

  socket.on('disconnect', () => {
    setDisconnected();
  });
}

sendBtn.addEventListener('click', () => sendMessage());
textInput.addEventListener('keydown', (e) => {
  if(e.key === 'Enter' && (e.ctrlKey || e.metaKey)) sendMessage();
});

function sendMessage(){
  const text = textInput.value.trim();
  if(!text || !socket) return;
  socket.emit('message', { text });
  textInput.value = '';
}

// Notifications
function notifyNewMessage(msg){
  // title badge
  const originalTitle = document.title;
  document.title = 'Neue Nachricht — ' + originalTitle;
  setTimeout(()=> document.title = originalTitle, 3000);

  // browser notification
  if(Notification && Notification.permission === 'granted'){
    const n = new Notification(msg.name, { body: msg.text });
    n.onclick = () => window.focus();
  } else if(Notification && Notification.permission !== 'denied'){
    Notification.requestPermission().then(p => {
      if(p === 'granted'){
        const n = new Notification(msg.name, { body: msg.text });
        n.onclick = () => window.focus();
      }
    });
  }

  // simple beep
  try {
    const ctx = new (window.AudioContext || window.webkitAudioContext)();
    const o = ctx.createOscillator();
    const g = ctx.createGain();
    o.type = 'sine';
    o.frequency.value = 800;
    o.connect(g);
    g.connect(ctx.destination);
    g.gain.value = 0.02;
    o.start();
    setTimeout(() => { o.stop(); ctx.close(); }, 120);
  } catch(e){}
}
</script>
</body>
</html>
